"""usage:
python MM(month in 2 digits)
1.Domain is determined by the template chosen.
2.One file(month) at a time. The resultant file will not be overwritten.
3.nc files may be corrupted if not properly written. must be remove before redoing.
"""
import numpy as np
from PseudoNetCDF.camxfiles.uamiv.Memmap import uamiv
from PseudoNetCDF.pncgen import pncgen
from pandas import *
from calendar import monthrange
import sys, os, subprocess
import netCDF4
import twd97
import datetime
from include3 import dt2jul, jul2dt, disc



#Main
#import the gridded area sources
P='/nas1/TEDS/teds11/biog/'
fname=P+'biogrid2019.csv'
df = read_csv(fname)

#time and space initiates
mm=sys.argv[1]
mo=int(mm)
yr=2019
ntm=(monthrange(yr,mo)[1]+2)*24+1
bdate=datetime.datetime(yr,mo,1)+datetime.timedelta(days=-1+8./24)
edate=bdate+datetime.timedelta(days=monthrange(yr,mo)[1]+3)

#prepare the uamiv template
fname='fortBE.413_teds10.biog'+mm+'.nc'
try:
  nc = netCDF4.Dataset(fname, 'r+')
except:
  os.system('cp '+P+'template_d4.nc '+fname)
  nc = netCDF4.Dataset(fname, 'r+')
V=[list(filter(lambda x:nc.variables[x].ndim==j, [i for i in nc.variables])) for j in [1,2,3,4]]
nt,nlay,nrow,ncol=nc.variables[V[3][0]].shape
nv=len(V[3])
nc.SDATE,nc.STIME=dt2jul(bdate)
nc.EDATE,nc.ETIME=dt2jul(edate)
nc.NOTE='grid Emission'
nc.NOTE=nc.NOTE+(60-len(nc.NOTE))*' '
#Name-names may encounter conflicts with newer versions of NCFs and PseudoNetCDFs.
#nc.NAME='EMISSIONS '
if 'ETFLAG' not in V[2]:
  zz=nc.createVariable('ETFLAG',"i4",("TSTEP","VAR","DATE-TIME"))
if nt!=ntm:
  for t in range(ntm):
    sdate,stime=dt2jul(bdate+datetime.timedelta(days=t/24.))
    nc.variables['TFLAG'][t,:,0]=[sdate for i in range(nv)]
    nc.variables['TFLAG'][t,:,1]=[stime for i in range(nv)]
    ndate,ntime=dt2jul(bdate+datetime.timedelta(days=(t+1)/24.))
    nc.variables['ETFLAG'][t,:,0]=[ndate for i in range(nv)]
    nc.variables['ETFLAG'][t,:,1]=[ntime for i in range(nv)]
for v in V[3]:
  nc.variables[v][:]=0.
sdatetime=[jul2dt(nc.variables['TFLAG'][t,0,:]) for t in range(ntm)]


col=['PM','PM25', 'CO', 'NOX', 'NMHC', 'SOX'] #1NO   2NO2   3SO2   4NH3   5CCRS   6FCRS   7PAR
cole='tnmhc    iso    mono   onmhc  mbo'.split()
#define the crustals/primary sources
colv='OLE PAR TOL XYL FORM ALD2 ETH ISOP NR ETHA MEOH ETOH IOLE TERP ALDX PRPA BENZ ETHY ACET KET'.split()
icolv=[0,1,5,7]
NC=len(icolv)
c2v={colv[i]:colv[i] for i in icolv}
#name                          saroa     num cas             mw   ole   par   tol   xyl  form  ald2   eth  isop    nr
#ISOPRENE                       43243      88     78795    68.12                                            1.0
#TERPENES                       43123      19             136.23   0.5   6.0                    1.5
#A-PINENE                       43256      96     80568   136.24   0.5   6.0                    1.5
#unidentified                                             140.0    0.5   8.5                                       0.5              
#B-PINENE                       43257      97    127913   136.24

#NSPEC=4;NCBM=5)
CBM=np.zeros(shape=(5,6))
CBM[1,4]=1.0
CBM[2,1:4]=[0.5 ,6.0 ,1.5]
CBM[3,1:4]=[0.5 ,6.0 ,1.5]
CBM[4,1:3]=[0.5 ,8.5]
MW=[float(i) for i in '0,68.0,136.24,136.23,140.0'.split(',')]
#time variations for CBM's
#fact.csv is generated by BIO_FACT.f
dft=read_csv('fact.csv')
col=[i.replace(' ','') for i in dft.columns]
dft.columns=col
dft.ih=dft.ih-1
f24=np.zeros(shape=(24,NC))
for t in range(24):
  boo=(dft.ih==t) & (dft.LAND==5)
  idx=dft.loc[boo].index
  if len(idx)==0:continue
  icbm=np.array(dft.loc[idx,'ICBM'])-1
  fcbm=np.array(dft.loc[idx,'FACT'])
  f24[t,icbm]=fcbm[:]
f24=f24*24 #portions converted to rates
fact=np.zeros(shape=(ntm,NC))
hr=np.array([i.hour for i in sdatetime])
for i in range(NC):
  fact[:,i]=f24[hr,i]
#note the df is discarded
df=disc(df)
df=df.loc[df.mon==mo].reset_index(drop=True)
NREC=len(df)
df['KgpY2gpHr']=[1000./24./monthrange(yr,mo)[1] for mo in df.mon]
OTVOC=df.onmhc+df.mbo
SPEC=np.zeros(shape=(NREC,5))
SPEC[:,1]=df.iso
SPEC[:,2]=OTVOC/2.
SPEC[:,3]=df.mono
SPEC[:,4]=OTVOC/2.
for isp in range(1,5):
  SPEC[:,isp]=SPEC[:,isp]*df.KgpY2gpHr/MW[isp]
ssum=np.zeros(NREC)
for i in icolv: #NR not write
  v=colv[i]
  ii=icolv.index(i)
  ssum=0.
  for isp in range(1,4):
    ssum+=SPEC[:,isp]*CBM[isp,ii]
  df[v]=ssum

#Expand to ntm*NREC
sdt,ix,iy=(np.zeros(shape=(ntm*NREC),dtype=int) for i in range(3))
val=np.zeros(shape=(ntm*NREC,NC))
idatetime=np.array([i for i in range(ntm)],dtype=int)
for t in range(ntm):
  t1,t2=t*NREC,(t+1)*NREC
  ix[t1:t2]=list(df.IX)
  iy[t1:t2]=list(df.IY)
for t in range(ntm):
  t1,t2=t*NREC,(t+1)*NREC
  sdt[t1:t2]=idatetime[t]
  for v in range(NC):
    c=colv[icolv[v]]
    val[t1:t2,v]=fact[t,v]*np.array(df[c])
dfT=DataFrame({'idt':sdt,'IX':ix,'IY':iy})
for v in range(NC):
  c=colv[icolv[v]]
  dfT[c]=val[:,v]

#Filling to the template
df=dfT
for c in c2v:
  if c not in df.columns:sys.exit()
  if sum(df[c])==0.:continue
  if c2v[c] not in V[3]:continue
  #only positive values are filled
  dfc=df.loc[df[c]>0]
  #since the number of time schemes are limited, the filling process are done
  #by each values as a batch.
  #If one attempt to loop the df axis to the point of the record, it will be very slow to do so.
  imn,jmn=min(dfc.IX),min(dfc.IY)
  imx,jmx=max(max(dfc.IX)+abs(imn)+1,ncol), max(max(dfc.IY)+abs(jmn)+1,nrow)
  if imn<0 and imx+imn<ncol:sys.exit('negative indexing error in i')
  if jmn<0 and jmx+jmn<nrow:sys.exit('negative indexing error in j')

  z=np.zeros(shape=(ntm,jmx,imx))
  idx=dfc.index
  idt=np.array(dfc.loc[idx,'idt'])
  iy=np.array(dfc.loc[idx,'IY'])
  ix=np.array(dfc.loc[idx,'IX'])
  ss=np.array(dfc.loc[idx,c])
  #Note that negative indices are not bothersome and are only at the end of the axis.
  z[idt,iy,ix]=ss
  #also mapping whole matrix, NOT by parts
  nc.variables[c2v[c]][:,0,:,:]=z[:,:nrow,:ncol]

#pncgen(nc, fname, format = 'uamiv')
nc.close()
